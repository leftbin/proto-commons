// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: leftbin/commons/proto/v1/timeline/rpc/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// time line of resource is list of activity
/// and each activity holds the information of the state change happened on the resource
public struct Leftbin_Commons_Proto_V1_Timeline_Rpc_Activity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique identifier of the activity
  public var activityID: String = String()

  /// type of the activity to identity the crud operation happened on the resource
  public var activityType: Leftbin_Commons_Proto_V1_Timeline_Enums_ActivityType = .unspecified

  /// email id of the user who has done the activity
  public var actor: String = String()

  /// time stamp of when the activity was done
  public var creTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _creTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_creTs = newValue}
  }
  /// Returns true if `creTs` has been explicitly set.
  public var hasCreTs: Bool {return self._creTs != nil}
  /// Clears the value of `creTs`. Subsequent reads from it will return its default value.
  public mutating func clearCreTs() {self._creTs = nil}

  /// unique identifier of the resource the activity belongs to
  public var resourceID: String = String()

  /// type of the resource the activity belongs to.
  public var resourceType: String = String()

  /// this is valid in case of activity type updates.
  /// to capture the updates happened on specific fields and there
  public var updates: [Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityUpdate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _creTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the field in resource that got updated
  public var fieldName: String = String()

  /// data type of the field
  public var fieldType: String = String()

  /// old value of the field
  /// will be blank in case of filed type list
  public var oldValue: String = String()

  /// new value of the field
  /// will be blank in case of filed type list
  public var newValue: String = String()

  /// this is specific to field data type list
  /// will have the new values added to the list
  public var addedValues: [String] = []

  /// this is specific to field data type list
  /// will have the values removed from the list
  public var removedValues: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// response of paginated activity list
public struct Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total number of pages
  public var totalPages: Int32 = 0

  /// list of activities
  public var entries: [Leftbin_Commons_Proto_V1_Timeline_Rpc_Activity] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// input to get paginated activity list
public struct Leftbin_Commons_Proto_V1_Timeline_Rpc_ListActivityByResourceTypeAndResourceIdInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique identifier of the resource
  public var resourceID: String = String()

  /// type of the resource
  public var resourceType: String = String()

  /// pagination input
  public var pageInfo: Leftbin_Commons_Proto_V1_Pagination_PageInfo {
    get {return _pageInfo ?? Leftbin_Commons_Proto_V1_Pagination_PageInfo()}
    set {_pageInfo = newValue}
  }
  /// Returns true if `pageInfo` has been explicitly set.
  public var hasPageInfo: Bool {return self._pageInfo != nil}
  /// Clears the value of `pageInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPageInfo() {self._pageInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageInfo: Leftbin_Commons_Proto_V1_Pagination_PageInfo? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Leftbin_Commons_Proto_V1_Timeline_Rpc_Activity: @unchecked Sendable {}
extension Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityUpdate: @unchecked Sendable {}
extension Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityList: @unchecked Sendable {}
extension Leftbin_Commons_Proto_V1_Timeline_Rpc_ListActivityByResourceTypeAndResourceIdInput: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "leftbin.commons.proto.v1.timeline.rpc"

extension Leftbin_Commons_Proto_V1_Timeline_Rpc_Activity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Activity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "activity_id"),
    2: .standard(proto: "activity_type"),
    3: .same(proto: "actor"),
    4: .standard(proto: "cre_ts"),
    5: .standard(proto: "resource_id"),
    6: .standard(proto: "resource_type"),
    7: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.activityType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.actor) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._creTs) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 1)
    }
    if self.activityType != .unspecified {
      try visitor.visitSingularEnumField(value: self.activityType, fieldNumber: 2)
    }
    if !self.actor.isEmpty {
      try visitor.visitSingularStringField(value: self.actor, fieldNumber: 3)
    }
    try { if let v = self._creTs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 5)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 6)
    }
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_Activity, rhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_Activity) -> Bool {
    if lhs.activityID != rhs.activityID {return false}
    if lhs.activityType != rhs.activityType {return false}
    if lhs.actor != rhs.actor {return false}
    if lhs._creTs != rhs._creTs {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
    2: .standard(proto: "field_type"),
    3: .standard(proto: "old_value"),
    4: .standard(proto: "new_value"),
    5: .standard(proto: "added_values"),
    6: .standard(proto: "removed_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fieldType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oldValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newValue) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.addedValues) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.removedValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    if !self.fieldType.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldType, fieldNumber: 2)
    }
    if !self.oldValue.isEmpty {
      try visitor.visitSingularStringField(value: self.oldValue, fieldNumber: 3)
    }
    if !self.newValue.isEmpty {
      try visitor.visitSingularStringField(value: self.newValue, fieldNumber: 4)
    }
    if !self.addedValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addedValues, fieldNumber: 5)
    }
    if !self.removedValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedValues, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityUpdate, rhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityUpdate) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.fieldType != rhs.fieldType {return false}
    if lhs.oldValue != rhs.oldValue {return false}
    if lhs.newValue != rhs.newValue {return false}
    if lhs.addedValues != rhs.addedValues {return false}
    if lhs.removedValues != rhs.removedValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_pages"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalPages) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalPages != 0 {
      try visitor.visitSingularInt32Field(value: self.totalPages, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityList, rhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_ActivityList) -> Bool {
    if lhs.totalPages != rhs.totalPages {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Leftbin_Commons_Proto_V1_Timeline_Rpc_ListActivityByResourceTypeAndResourceIdInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActivityByResourceTypeAndResourceIdInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_id"),
    2: .standard(proto: "resource_type"),
    3: .standard(proto: "page_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pageInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 1)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 2)
    }
    try { if let v = self._pageInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_ListActivityByResourceTypeAndResourceIdInput, rhs: Leftbin_Commons_Proto_V1_Timeline_Rpc_ListActivityByResourceTypeAndResourceIdInput) -> Bool {
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs._pageInfo != rhs._pageInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
